<!DOCTYPE html>
<html>
    <head>
        <title> Multitexturing</title>
        <style>
            #overlay {
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                font-family: monospace;
                padding: 1em;
                border-radius: 1em;
                border: 1px solid #f00;
                text-shadow: 0px 0px 1px white;
            }
        </style>
        
        <script src="Common/js/gl.js"></script>
        <script src="Common/js/shaders.js"></script>
        <script src="Common/js/gl-matrix.js"></script>
        <script src="Common/js/RenderLoop.js"></script>
        <script src="Common/js/jquery-3.3.1.min.js"></script>
        <script src="Common/js/jquery-ui-1.12.1/jquery-ui.js"></script>
        <link href='Common/js/jquery-ui-1.12.1/jquery-ui.min.css' type='text/css' rel='stylesheet' />
        <script type='text/javascript' src='Common/js/colorpicker.js'></script>
        <link href='Common/css/style.css' type='text/css' rel='stylesheet' />
        <link href='Common/css/colorpicker.css' type='text/css' rel='stylesheet' />
        
        <script>
            "use strict"
            var gl;
            var vertexArray;
            var vertexArray2;
            var vertexBuffer;
            var vertexBuffer2;
            var colorBuffer;
            var shaderProg;
            var shaderProg2;
            var vColor;
            var points = [];
            var colors = [];
            var vertices = [];
            var vertexColors = [];
            var translations = [];
            var rLoop;
            var modelViewMatrix = mat4.create();
            var projectionMatrix = mat4.create();
            var modelViewMatrixStack = [];
            var fovy = glMatrix.toRadian(45.0);  // vertical Field-of-view (in Y direction) angle (in radians)
            const at = vec3.clone([0.0, 0.0, 0.0]);
            const up = vec3.clone([0.0, 1.0, 0.0]);
            var near = 0.1;
            var far = 100;
            var radius = 10.0;
            var aspect = 1.0;
            //var theta = 10.0 * Math.PI / 180.0;
            var theta = 0.5;
            var phi = 1.5;
            var dr = 5.0 * Math.PI / 180.0;
            var cubeVertexPositionBuffer;
            var cubeVertexIndexBuffer;
            var axis = 0;
            var xAxis = 0;
            var yAxis = 1;
            var zAxis = 2;
            var rtheta = [0, 0, 0];
            var flag = false;
            var normalsArray = [];
            var normalBuffer;
            var normalMatrix = mat4.create();
            //var lightDirection = [0.0,2.0, 0.0];
            var lightPosition = [-1.0, -4.0, 3.0, 0.0];
            var lightAmbient = [0.2, 0.2, 0.2, 1.0];
            var lightDiffuse = [1.0, 1.0, 1.0, 1.0];
            var lightSpecular = [1.0, 1.0, 1.0, 1.0];
            var materialAmbient = [1.0, 0.0, 1.0, 1.0];
            var materialDiffuse = [1.0, 0.8, 0.0, 1.0];
            var materialSpecular = [1.0, 1.0, 1.0, 1.0];
            var materialShininess = 20.0;
            var diffuseColor;
            var textureBuffer;
            var texCoordsArray = [];
            var texCoord = [];
            var texture;
            var texture2;
            var texSize = 64;
          
            window.addEventListener("load", function () {
                                    gl = GLInstance("myGLCanvas").fSetSize(500, 500).fClear();
                                    gl.enable(gl.DEPTH_TEST);
                                    setupShaders();
                                    setupLights();
                                    setupTextures();
                                    setupBuffers();
                                    rLoop = new RenderLoop(draw).start();
                                    });
                                    function setupShaders() {
                                        shaderProg = ShaderUtil.domShaderProgram(gl, "vertex_shader", "fragment_shader", true);
                                        gl.useProgram(shaderProg);
                                        shaderProg.aPositionLoc = gl.getAttribLocation(shaderProg, "a_position");
                                        shaderProg.vColor = gl.getAttribLocation(shaderProg, "vColorAttr");
                                        shaderProg.modelViewMatrixLoc = gl.getUniformLocation(shaderProg, "modelViewMatrix");
                                        shaderProg.projectionMatrixLoc = gl.getUniformLocation(shaderProg, "projectionMatrix");
                                        shaderProg.normalMatrixLoc = gl.getUniformLocation(shaderProg, "normalMatrix");
                                        shaderProg.vNormal = gl.getAttribLocation(shaderProg, "vNormalAttr");
                                        shaderProg.lightPosition = gl.getUniformLocation(shaderProg, "lightPosition");
                                        shaderProg.materialDiffuse = gl.getUniformLocation(shaderProg, "materialDiffuse");
                                        shaderProg.lightDiffuse = gl.getUniformLocation(shaderProg, "lightDiffuse");
                                        shaderProg.materialAmbient = gl.getUniformLocation(shaderProg, "materialAmbient");
                                        shaderProg.lightAmbient = gl.getUniformLocation(shaderProg, "lightAmbient");
                                        shaderProg.materialSpecular = gl.getUniformLocation(shaderProg, "materialSpecular");
                                        shaderProg.lightSpecular = gl.getUniformLocation(shaderProg, "lightSpecular");
                                        shaderProg.shininess = gl.getUniformLocation(shaderProg, "shininess");
                                        shaderProg.vTexCoord = gl.getAttribLocation(shaderProg, "vTexCoord");
                                        shaderProg.uTexture = gl.getUniformLocation(shaderProg, "textureMap");
                                        shaderProg.uTexture2 = gl.getUniformLocation(shaderProg, "textureMap2");
                                        gl.useProgram(null);
                                        shaderProg2 = ShaderUtil.domShaderProgram(gl, "vertex_shader2", "fragment_shader2", true);
                                        gl.useProgram(shaderProg2);
                                        shaderProg2.aPositionLoc = gl.getAttribLocation(shaderProg2, "a_position");
                                        shaderProg2.vColor = gl.getAttribLocation(shaderProg2, "vColorAttr");
                                        shaderProg2.modelViewMatrixLoc = gl.getUniformLocation(shaderProg2, "modelViewMatrix");
                                        shaderProg2.projectionMatrixLoc = gl.getUniformLocation(shaderProg2, "projectionMatrix");
                                        gl.useProgram(null);
                                    }
        function setupCoordinates() {
            //Dynamiclly create a grid
            var myVerts = [];
            var verts = [-10.0, 0.0, 0.0, 10.0, 0.0, 0.0,
                         0.0, -10.0, 0.0, 0.0, 10.0, 0.0,
                         0.0, 0.0, -10.0, 0.0, 0.0, 10.0]; //x,y,z coordinates 6 vertices
                         myVerts = new Float32Array(verts);
                         return myVerts;
        }
        function setupVertices() {
            quad(1, 0, 3, 2);
            quad(2, 3, 7, 6);
            quad(3, 0, 4, 7);
            quad(6, 5, 1, 2);
            quad(4, 5, 6, 7);
            quad(5, 4, 0, 1);
        }
        function quad(a, b, c, d) {
            vertices[0] = vec3.clone([-1.0, -1.0, 1.0]);
            vertices[1] = vec3.clone([-1.0, 1.0, 1.0]);
            vertices[2] = vec3.clone([1.0, 1.0, 1.0]);
            vertices[3] = vec3.clone([1.0, -1.0, 1.0]);
            vertices[4] = vec3.clone([-1.0, -1.0, -1.0]);
            vertices[5] = vec3.clone([-1.0, 1.0, -1.0]);
            vertices[6] = vec3.clone([1.0, 1.0, -1.0]);
            vertices[7] = vec3.clone([1.0, -1.0, -1.0]);
            vertexColors[0] = vec3.clone([244, 164, 96]);// sandy brown
            vertexColors[1] = vec3.clone([222, 184, 135]); //buly wood
            vertexColors[2] = vec3.clone([205, 133, 63]);// peru
            vertexColors[3] = vec3.clone([210, 105, 30]);// chocolate
            vertexColors[4] = vec3.clone([139, 69, 19]);// saddle brown
            vertexColors[5] = vec3.clone([160, 82, 45]);// sienna
            vertexColors[6] = vec3.clone([165, 42, 42]); // brown
            vertexColors[7] = vec3.clone([128, 0, 0]);// maroon
            texCoord[0] = vec2.clone([0, 0]);
            texCoord[1] = vec2.clone([0, 1]);
            texCoord[2] = vec2.clone([1, 1]);
            texCoord[3] = vec2.clone([0, 0]);
            texCoord[4] = vec2.clone([1, 1]);
            texCoord[5] = vec2.clone([1, 0]);
            var indices = [a, b, c, a, c, d];
            for (var i = 0; i < indices.length; ++i) {
                points.push(...vertices[indices[i]]);
                // different color for all faces
                colors.push(...vertexColors[a]);
                texCoordsArray.push(...texCoord[i]);
            }
            //adding normals for 6 vertices
            let aVector = vec3.create();
            let bVector = vec3.create();
            let normalVector = vec3.create();
            let normalVector4 = vec4.create();
            vec3.subtract(aVector, vertices[b], vertices[a]);
            vec3.subtract(bVector, vertices[c], vertices[b]);
            vec3.cross(normalVector, aVector, bVector);
            vec3.normalize(normalVector, normalVector);
            vec4.set(normalVector4, normalVector[0], normalVector[1], normalVector[2], 0.0);
            normalsArray.push(...normalVector4);
            normalsArray.push(...normalVector4);
            normalsArray.push(...normalVector4);
            normalsArray.push(...normalVector4);
            normalsArray.push(...normalVector4);
            normalsArray.push(...normalVector4);
        }
        function setupBuffers() {
            gl.useProgram(shaderProg);
            vertexArray = gl.createVertexArray();
            gl.bindVertexArray(vertexArray);
            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            setupVertices();
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            vertexBuffer.itemSize = 3;
            vertexBuffer.numberOfItems = points.length / 3;
            gl.enableVertexAttribArray(shaderProg.aPositionLoc);
            gl.vertexAttribPointer(shaderProg.aPositionLoc, 3, gl.FLOAT, false, 0, 0);
            colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(colors), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(shaderProg.vColor);
            gl.vertexAttribPointer(shaderProg.vColor, 3, gl.UNSIGNED_BYTE, true, 0, 0);
            normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalsArray), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(shaderProg.vNormal);
            gl.vertexAttribPointer(shaderProg.vNormal, 4, gl.FLOAT, false, 0, 0);
            textureBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoordsArray), gl.STATIC_DRAW);
            gl.vertexAttribPointer(shaderProg.vTexCoord, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(shaderProg.vTexCoord);
            gl.bindVertexArray(null);
            gl.useProgram(null);
            gl.useProgram(shaderProg2);
            vertexArray2 = gl.createVertexArray();
            gl.bindVertexArray(vertexArray2);
            vertexBuffer2 = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer2);
            var vertices = setupCoordinates();
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            vertexBuffer.itemSize = 3;
            vertexBuffer.numberOfItems = vertices.length / 3;
            gl.enableVertexAttribArray(shaderProg.aPositionLoc);
            gl.vertexAttribPointer(shaderProg.aPositionLoc, 3, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
            gl.useProgram(null);
        }
        function setupTextures() {
            var image = document.getElementById("texImage");
            configureTexture(image);
            
            var image1 = new Array()
            for (var i = 0; i < texSize; i++) image1[i] = new Array();
            for (var i = 0; i < texSize; i++)
            for (var j = 0; j < texSize; j++)
            image1[i][j] = new Float32Array(4);
            for (var i = 0; i < texSize; i++) for (var j = 0; j < texSize; j++) {
                var c = (((i & 0x8) == 0) ^ ((j & 0x8) == 0));
                image1[i][j] = [c, c, c, 1];
            }
            
            // Convert floats to ubytes for texture
            
            var image2 = new Uint8Array(4 * texSize * texSize);
            
            for (var i = 0; i < texSize; i++)
            for (var j = 0; j < texSize; j++)
            for (var k = 0; k < 4; k++)
            image2[4 * texSize * i + 4 * j + k] = 255 * image1[i][j][k];
            
            configureTexture2(image2);
        }
        function configureTexture(image) {
            gl.activeTexture(gl.TEXTURE0);
            texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB,
                          gl.RGB, gl.UNSIGNED_BYTE, image);
                          gl.generateMipmap(gl.TEXTURE_2D);
                          gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,gl.NEAREST_MIPMAP_LINEAR );
                          gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
                          gl.uniform1i(shaderProg.uTexture, 0);
        }
        
        function configureTexture2(image) {
            gl.activeTexture(gl.TEXTURE1);
            texture2 = gl.createTexture();
            gl.bindTexture( gl.TEXTURE_2D, texture2 );
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D( gl.TEXTURE_2D, 0,  gl.RGBA,  texSize, texSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.generateMipmap( gl.TEXTURE_2D );
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.uniform1i(shaderProg.uTexture2, 1);
        }
        
        function setupLights() {
            gl.useProgram(shaderProg);
            gl.uniform4fv(shaderProg.lightDiffuse, lightDiffuse);
            gl.uniform4fv(shaderProg.materialDiffuse, materialDiffuse);
            gl.uniform4fv(shaderProg.lightAmbient, lightAmbient);
            gl.uniform4fv(shaderProg.materialAmbient, materialAmbient);
            gl.uniform4fv(shaderProg.lightSpecular, lightSpecular);
            gl.uniform4fv(shaderProg.materialSpecular, materialSpecular);
            gl.uniform4fv(shaderProg.lightPosition, lightPosition);
            gl.uniform1f(shaderProg.shininess, materialShininess);
        }
        function draw() {
            gl.fClear();
            gl.useProgram(shaderProg);
            gl.bindVertexArray(vertexArray);
            if (flag) rtheta[axis] += 0.05;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            modelViewMatrix = mat4.create();
            normalMatrix = mat4.create();
            let eye = vec3.clone([radius * Math.sin(theta) * Math.cos(phi),
                                  radius * Math.sin(theta) * Math.sin(phi), radius * Math.cos(theta)]);
                                  mat4.lookAt(modelViewMatrix, eye, at, up);
                                  mat4.rotate(modelViewMatrix, modelViewMatrix, rtheta[xAxis], [1, 0, 0]);
                                  mat4.rotate(modelViewMatrix, modelViewMatrix, rtheta[yAxis], [0, 1, 0]);
                                  mat4.rotate(modelViewMatrix, modelViewMatrix, rtheta[zAxis], [0, 0, 1]);
                                  mat4.perspective(projectionMatrix, fovy, aspect, near, far);
                                  gl.uniformMatrix4fv(shaderProg.modelViewMatrixLoc, false, modelViewMatrix);
                                  mat4.invert(normalMatrix, modelViewMatrix);
                                  gl.uniformMatrix4fv(shaderProg.projectionMatrixLoc, false, projectionMatrix);
                                  gl.uniformMatrix4fv(shaderProg.normalMatrixLoc, true, normalMatrix);
                                  pushModelViewMatrix();
                                  mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 1.1, 0.0]);
                                  mat4.invert(normalMatrix, modelViewMatrix);
                                  gl.uniformMatrix4fv(shaderProg.modelViewMatrixLoc, false, modelViewMatrix);
                                  gl.uniformMatrix4fv(shaderProg.normalMatrixLoc, true, normalMatrix);
                                  gl.uniform4fv(shaderProg.lightPosition, lightPosition);
                                  drawTable();
                                  popModelViewMatrix();
                                  //creating shadow
                                  let shadowMatrix = mat4.create();
                                  shadowMatrix[15] = 0.0;
                                  shadowMatrix[7] = -1 / lightPosition[1];
                                  //pushModelViewMatrix();
                                  //mat4.translate(modelViewMatrix, modelViewMatrix, [lightPosition[0], lightPosition[1], lightPosition[2]]);
                                  //mat4.multiply(modelViewMatrix, modelViewMatrix, shadowMatrix);
                                  //mat4.translate(modelViewMatrix, modelViewMatrix, [-lightPosition[0], -lightPosition[1], -lightPosition[2]]);
                                  //mat4.invert(normalMatrix, modelViewMatrix);
                                  //gl.uniformMatrix4fv(shaderProg.modelViewMatrixLoc, false, modelViewMatrix);
                                  //gl.uniformMatrix4fv(shaderProg.normalMatrixLoc, true, normalMatrix);
                                  //gl.disableVertexAttribArray(shaderProg.vColor);
                                  //gl.vertexAttrib3f(shaderProg.vColor, 0.3, 0.3, 0.3);
                                  //drawTable();
                                  //gl.enableVertexAttribArray(shaderProg.vColor);
                                  //popModelViewMatrix();
                                  gl.bindVertexArray(null);
                                  gl.useProgram(null);
                                  //draw x-y axes
                                  gl.useProgram(shaderProg2);
                                  gl.bindVertexArray(vertexArray2);
                                  modelViewMatrix = mat4.create();
                                  mat4.lookAt(modelViewMatrix, eye, at, up);
                                  mat4.perspective(projectionMatrix, fovy, aspect, near, far);
                                  gl.uniformMatrix4fv(shaderProg2.modelViewMatrixLoc, false, modelViewMatrix);
                                  gl.uniformMatrix4fv(shaderProg2.projectionMatrixLoc, false, projectionMatrix);
                                  gl.disableVertexAttribArray(shaderProg2.vColor);
                                  gl.vertexAttrib3f(shaderProg2.vColor, 1.0, 0.0, 0.0);
                                  gl.drawArrays(gl.LINES, 0, 2);
                                  gl.vertexAttrib3f(shaderProg2.vColor, 0, 255, 0);
                                  gl.drawArrays(gl.LINES, 2, 2);
                                  gl.vertexAttrib3f(shaderProg2.vColor, 0, 0, 255);
                                  gl.drawArrays(gl.LINES, 4, 2);
                                  gl.bindVertexArray(null);
                                  gl.useProgram(null);
        }
        function pushModelViewMatrix() {
            var copyToPush = mat4.clone(modelViewMatrix);
            modelViewMatrixStack.push(copyToPush);
        }
        function popModelViewMatrix() {
            if (modelViewMatrixStack.length == 0) {
                throw "Error popModelViewMatrix() - Stack was empty ";
            }
            modelViewMatrix = modelViewMatrixStack.pop();
        }
        function drawTable() {
            // Draw table top
            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 1.0, 0.0]);
            mat4.scale(modelViewMatrix, modelViewMatrix, [2.0, 0.1, 2.0]);
            gl.uniformMatrix4fv(shaderProg.modelViewMatrixLoc, false, modelViewMatrix);
            gl.drawArrays(gl.TRIANGLES, 0, 36);
            popModelViewMatrix();
            // Draw table legs
            for (var i = -1; i <= 1; i += 2) {
                for (var j = -1; j <= 1; j += 2) {
                    pushModelViewMatrix();
                    mat4.translate(modelViewMatrix, modelViewMatrix, [i * 1.9, -0.1, j * 1.9]);
                    mat4.scale(modelViewMatrix, modelViewMatrix, [0.1, 1.0, 0.1]);
                    gl.uniformMatrix4fv(shaderProg.modelViewMatrixLoc, false, modelViewMatrix);
                    mat4.invert(normalMatrix, modelViewMatrix);
                    gl.uniformMatrix4fv(shaderProg.normalMatrixLoc, true, normalMatrix);
                    gl.drawArrays(gl.TRIANGLES, 0, 36);
                    popModelViewMatrix();
                }
            }
        }
        </script>
        
        <script>
            $(function () {
              $('#rotatex-btn').button();
              $('#rotatex-btn').click(
                                      function () {
                                      if ($('#rotatex-btn:checked').val() == null) {
                                      }
                                      else {
                                      axis = xAxis;
                                      }
                                      });
              $('#rotatey-btn').button();
              $('#rotatey-btn').click(
                                      function () {
                                      if ($('#rotatey-btn:checked').val() == null) {
                                      }
                                      else {
                                      axis = yAxis;
                                      }
                                      });
              $('#rotatez-btn').button();
              $('#rotatez-btn').click(
                                      function () {
                                      if ($('#rotatez-btn:checked').val() == null) {
                                      }
                                      else {
                                      axis = zAxis;
                                      }
                                      });
              $('#rotatet-btn').button();
              $('#rotatet-btn').click(
                                      function () {
                                      if ($('#rotatet-btn:checked').val() == null) {
                                      }
                                      else {
                                      flag = !flag;
                                      }
                                      });
              $("#increaseZ-btn").button();
              $("#increaseZ-btn").click(function () { near *= 1.1; far *= 1.1; });
              $("#decreaseZ-btn").button();
              $("#decreaseZ-btn").click(function () { near *= 0.9; far *= 0.9; });
              $("#increaseRadius-btn").button();
              $("#increaseRadius-btn").click(function () { radius *= 1.1; });
              $("#decreaseRadius-btn").button();
              $("#decreaseRadius-btn").click(function () { radius *= 0.9; });
              $("#increaseTheta-btn").button();
              $("#increaseTheta-btn").click(function () { theta += dr; });
              $("#decreaseTheta-btn").button();
              $("#decreaseTheta-btn").click(function () { theta -= dr; });
              $("#increasePhi-btn").button();
              $("#increasePhi-btn").click(function () { phi += dr; });
              $("#decreasePhi-btn").button();
              $("#decreasePhi-btn").click(function () { phi -= dr; });
              function updateProjection() {
              fovy = $('#slider-fovy').slider("value");
              $('#slider-fovy-value').html(fovy);
              aspect = $('#slider-aspect').slider("value");
              $('#slider-aspect-value').html(aspect);
              }
              $('#slider-fovy').slider({ value: 45, min: 10, max: 120, step: 5, slide: updateProjection });
              $('#slider-aspect').slider({ value: 1, min: 0.5, max: 2, step: 0.1, slide: updateProjection });
              $('#slider-x').slider({ value: -1, min: -5, max: 5, step: 1, slide: updateLightDirection });
              $('#slider-y').slider({ value: -4, min: -5, max: 5, step: 1, slide: updateLightDirection });
              $('#slider-z').slider({ value: 3, min: -5, max: 5, step: 1, slide: updateLightDirection });
              function updateLightDirection() {
              lightPosition[0] = $('#slider-x').slider("value");
              lightPosition[1] = $('#slider-y').slider("value");
              lightPosition[2] = $('#slider-z').slider("value");
              //gl.uniform4fv(shaderProg.lightPosition, [x, y, z, 0.0]);
              $('#slider-x-value').html(  lightPosition[0]);
              $('#slider-y-value').html(  lightPosition[1]);
              $('#slider-z-value').html(  lightPosition[2]);
              }
              });
            </script>
        
    </head>
    <body>
        <div id="overlay">
            Multitexturing. X-axis: Red, Y-axis: Green, Z-axis: Blue
            <p />
            
            
            <div>
                <table>
                    <tr>
                        <td align='left'>light(x)</td>
                        <td id='slider-x-value' width='30px' align='center'>0</td>
                        <td width='150px'><div id='slider-x' /></td>
                        <td align='left'>light(y)</td>
                        <td id='slider-y-value' width='30px' align='center'>0</td>
                        <td width='150px'><div id='slider-y' /></td>
                        <td align='left'>light(z)</td>
                        <td id='slider-z-value' width='30px' align='center'>0</td>
                        <td width='150px'><div id='slider-z' /></td>
                    </tr>
                </table>
            </div>
            <div>
                <table>
                    <tr>
                        <td><label id='lblrotatex' for='rotatex-btn'>Rotate X</label><input id='rotatex-btn' type='checkbox' /></td>
                        <td><label id='lblrotatey' for='rotatey-btn'>Rotate Y</label><input id='rotatey-btn' type='checkbox' /></td>
                        <td><label id='lblrotatez' for='rotatez-btn'>Rotate Z</label><input id='rotatez-btn' type='checkbox' /></td>
                        <td><label id='lblrotatet' for='rotatet-btn'>Toggle Rotation</label><input id='rotatet-btn' type='checkbox' /></td>
                        <td align='left'>fovy</td>
                        <td id='slider-fovy-value' width='30px' align='center'>120</td>
                        <td width='150px'><div id='slider-fovy' /></td>
                        <td align='left'>aspect</td>
                        <td id='slider-aspect-value' width='30px' align='center'>2</td>
                        <td width='150px'><div id='slider-aspect' /></td>
                        
                    </tr>
                </table>
                
                <p />
                <button id="increaseZ-btn">Increase Z</button>
                <button id="decreaseZ-btn">Decrease Z</button>
                <button id="increaseRadius-btn">Increase R</button>
                <button id="decreaseRadius-btn">Decrease R</button>
                <p> </p>
                <button id="increaseTheta-btn">Increase theta</button>
                <button id="decreaseTheta-btn">Decrease theta</button>
                <button id="increasePhi-btn">Increase phi</button>
                <button id="decreasePhi-btn">Decrease phi</button>
                
            </div>
            <p></p>
            
        </div>
        </div>
        
        <div>
            <img id="texImage" src="wood_128x128.jpg" style="display:none" crossorigin="anonymous" />
            <canvas id="myGLCanvas"></canvas>
        </div>
        
        <script id="vertex_shader" type="x-shader/x-vertex">#version 300 es
            in vec3 a_position;
            in vec3 vColorAttr;
            out vec4 vColor;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            in vec4 vNormalAttr;
            uniform vec4 lightPosition;
            uniform mat4 normalMatrix;
            out vec3 L;
            out vec3 N;
            out vec3 E;
            in vec2 vTexCoord;
            out vec2 fTexCoord;
            void main(void){
                // pos is vertex position in eye coordinates
                vec3 pos = (modelViewMatrix * vec4(a_position, 1.0)).xyz;
                //Transformed normal position
                N = vec3(normalMatrix * vNormalAttr);
                vec3 eyeVec = -vec3(pos);
                E = eyeVec;
                // check for directional light
                if(lightPosition.w == 0.0) L = lightPosition.xyz;
                else L =  lightPosition.xyz - pos ;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(a_position, 1.0);
                vColor = vec4(vColorAttr, 1.0);
                fTexCoord = vTexCoord;
            }
        </script>
        <script id="fragment_shader" type="x-shader/x-fragment">#version 300 es
            precision mediump float;
            in vec4 vColor;
            out vec4 finalColor;
            uniform vec4 lightDiffuse;
            uniform vec4 materialDiffuse;
            uniform vec4 lightAmbient;
            uniform vec4 materialAmbient;
            uniform vec4 lightSpecular;
            uniform vec4 materialSpecular;
            uniform float shininess;
            in vec3 L;
            in vec3 N;
            in vec3 E;
            vec3 nL, nN, nE;
            in  vec2 fTexCoord;
            uniform sampler2D textureMap;
            uniform sampler2D textureMap2;
            void main(void) {
                nE = normalize(E);
                nN = normalize(N);
                nL = normalize(L);
                //Lambert's cosine law
                float lambertTerm = dot(nN,-nL);
                float Kd = max (dot (nN, -nL) , 0.0);
                //Ambient Term
                vec4 Ia = lightAmbient * materialAmbient;
                //Diffuse Term
                vec4 Id = vec4(0.0,0.0,0.0,1.0);
                //Specular Term
                vec4 Is = vec4(0.0,0.0,0.0,1.0);
                if(lambertTerm > 0.0) //only if lambertTerm is positive
                {
                    Id = lightDiffuse * texture( textureMap, fTexCoord ) * texture( textureMap2, fTexCoord ) * lambertTerm; //add diffuse term
                    vec3 R = reflect(nL, nN);
                    float specular = pow(max(dot(R, nE), 0.0), shininess );
                    Is = lightSpecular * materialSpecular * specular; //add specular term
                }
                finalColor = Ia + Id + Is;
                finalColor.a = 1.0;
            }
        </script>
        <script id="vertex_shader2" type="x-shader/x-vertex">#version 300 es
            in vec3 a_position;
            in vec3 vColorAttr;
            out vec4 vColor;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            void main(void){
                gl_Position = projectionMatrix * modelViewMatrix * vec4(a_position, 1.0);
                vColor = vec4(vColorAttr, 1.0);
            }
        </script>
        <script id="fragment_shader2" type="x-shader/x-fragment">#version 300 es
            precision highp float;
            in vec4 vColor;
            out vec4 finalColor;
            void main(void) {
                finalColor = vColor;
            }
        </script>
        
    </body>
</html>
