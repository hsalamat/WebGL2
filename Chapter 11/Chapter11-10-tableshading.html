<!DOCTYPE html>
<html>
<head>
    <title> Interactive Shading of a Table</title>
    <style>
        #overlay {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: monospace;
            padding: 1em;
            border-radius: 1em;
            border: 1px solid #f00;
            text-shadow: 0px 0px 1px white;
        }
    </style>

    <script src="Common/js/gl.js"></script>
    <script src="Common/js/shaders.js"></script>
    <script src="Common/js/gl-matrix.js"></script>
    <script src="Common/js/RenderLoop.js"></script>
    <script src="Common/js/jquery-3.3.1.min.js"></script>
    <script src="Common/js/jquery-ui-1.12.1/jquery-ui.js"></script>
    <link href='Common/js/jquery-ui-1.12.1/jquery-ui.min.css' type='text/css' rel='stylesheet' />
    <script type='text/javascript' src='Common/js/colorpicker.js'></script>
    <link href='Common/css/style.css' type='text/css' rel='stylesheet' />
    <link href='Common/css/colorpicker.css' type='text/css' rel='stylesheet' />

    <script>
        "use strict"
        var gl;
        var vertexArray;
        var vertexArray2;
        var vertexBuffer;
        var vertexBuffer2;
        var colorBuffer;
        var shaderProg;
        var shaderProg2;
        var vColor;
        var points = [];
        var colors = [];
        var vertices = [];
        var vertexColors = [];
        var translations = [];
        var rLoop;
        var modelViewMatrix = mat4.create();
        var projectionMatrix = mat4.create();
        var modelViewMatrixStack = [];
        var fovy = glMatrix.toRadian(70.0);  // vertical Field-of-view (in Y direction) angle (in radians)
        const at = vec3.clone([0.0, 0.0, 0.0]);
        const up = vec3.clone([0.0, 1.0, 0.0]);
        var near = 0.1;
        var far = 100;
        var radius = 10.0;
        var aspect = 1.0;
        //var theta = 10.0 * Math.PI / 180.0;
        var theta = 0.8726646259971648;
        var phi = 1.5707963267948966;
        var dr = 5.0 * Math.PI / 180.0;
        var cubeVertexPositionBuffer;
        var cubeVertexIndexBuffer;
        var light = [0.0, 2.0, 0.0];
        var axis = 0;
        var xAxis = 0;
        var yAxis = 1;
        var zAxis = 2;
        var rtheta = [0, 0, 0];
        var flag = false;


        var normalsArray = [];
        var normalBuffer;
        var normalMatrix = mat4.create();
        //var lightDirection = [0.0,-1.0, -1.0];
        var lightPosition = [0.0, -1.0, -1.0, 0.0];
        var lightAmbient = [0.2, 0.2, 0.2, 1.0];
        var lightDiffuse = [1.0, 1.0, 1.0, 1.0];
        var lightSpecular = [1.0, 1.0, 1.0, 1.0];

        var materialAmbient = [1.0, 0.0, 1.0, 1.0];
        var materialDiffuse = [1.0, 0.8, 0.0, 1.0];
        var materialSpecular = [1.0, 1.0, 1.0, 1.0];
        var materialShininess = 20.0;

        var diffuseColor;


        window.addEventListener("load", function () {
            gl = GLInstance("myGLCanvas").fSetSize(500, 500).fClear();
            gl.enable(gl.DEPTH_TEST);
            setupShaders();
            setupLights();
            setupBuffers();
            rLoop = new RenderLoop(draw).start();
        });
        function setupShaders() {
            shaderProg = ShaderUtil.domShaderProgram(gl, "vertex_shader", "fragment_shader", true);
            gl.useProgram(shaderProg);
            shaderProg.aPositionLoc = gl.getAttribLocation(shaderProg, "a_position");
            shaderProg.vColor = gl.getAttribLocation(shaderProg, "vColorAttr");
            shaderProg.modelViewMatrixLoc = gl.getUniformLocation(shaderProg, "modelViewMatrix");
            shaderProg.projectionMatrixLoc = gl.getUniformLocation(shaderProg, "projectionMatrix");
            shaderProg.normalMatrixLoc = gl.getUniformLocation(shaderProg, "normalMatrix");

            shaderProg.vNormal = gl.getAttribLocation(shaderProg, "vNormalAttr");
            shaderProg.lightPosition = gl.getUniformLocation(shaderProg, "lightPosition");
            shaderProg.materialDiffuse = gl.getUniformLocation(shaderProg, "materialDiffuse");
            shaderProg.lightDiffuse = gl.getUniformLocation(shaderProg, "lightDiffuse");
            shaderProg.materialAmbient = gl.getUniformLocation(shaderProg, "materialAmbient");
            shaderProg.lightAmbient = gl.getUniformLocation(shaderProg, "lightAmbient");
            shaderProg.materialSpecular = gl.getUniformLocation(shaderProg, "materialSpecular");
            shaderProg.lightSpecular = gl.getUniformLocation(shaderProg, "lightSpecular");
            shaderProg.shininess = gl.getUniformLocation(shaderProg, "shininess");

            gl.useProgram(null);
            shaderProg2 = ShaderUtil.domShaderProgram(gl, "vertex_shader2", "fragment_shader2", true);
            gl.useProgram(shaderProg2);
            shaderProg2.aPositionLoc = gl.getAttribLocation(shaderProg2, "a_position");
            shaderProg2.vColor = gl.getAttribLocation(shaderProg2, "vColorAttr");
            shaderProg2.modelViewMatrixLoc = gl.getUniformLocation(shaderProg2, "modelViewMatrix");
            shaderProg2.projectionMatrixLoc = gl.getUniformLocation(shaderProg2, "projectionMatrix");
            gl.useProgram(null);
        }
        function setupCoordinates() {
            //Dynamiclly create a grid
            var myVerts = [];
            var verts = [-10.0, 0.0, 0.0, 10.0, 0.0, 0.0,
                0.0, -10.0, 0.0, 0.0, 10.0, 0.0,
                0.0, 0.0, -10.0, 0.0, 0.0, 10.0]; //x,y,z coordinates 6 vertices
            myVerts = new Float32Array(verts);
            return myVerts;
        }
        function setupVertices() {
            quad(1, 0, 3, 2);
            quad(2, 3, 7, 6);
            quad(3, 0, 4, 7);
            quad(6, 5, 1, 2);
            quad(4, 5, 6, 7);
            quad(5, 4, 0, 1);
        }
        function quad(a, b, c, d) {
            vertices[0] = vec3.clone([-1.0, -1.0, 1.0]);
            vertices[1] = vec3.clone([-1.0, 1.0, 1.0]);
            vertices[2] = vec3.clone([1.0, 1.0, 1.0]);
            vertices[3] = vec3.clone([1.0, -1.0, 1.0]);
            vertices[4] = vec3.clone([-1.0, -1.0, -1.0]);
            vertices[5] = vec3.clone([-1.0, 1.0, -1.0]);
            vertices[6] = vec3.clone([1.0, 1.0, -1.0]);
            vertices[7] = vec3.clone([1.0, -1.0, -1.0]);
            vertexColors[0] = vec3.clone([244, 164, 96]);// sandy brown
            vertexColors[1] = vec3.clone([222, 184, 135]); //buly wood
            vertexColors[2] = vec3.clone([205, 133, 63]);// peru
            vertexColors[3] = vec3.clone([210, 105, 30]);// chocolate
            vertexColors[4] = vec3.clone([139, 69, 19]);// saddle brown
            vertexColors[5] = vec3.clone([160, 82, 45]);// sienna
            vertexColors[6] = vec3.clone([165, 42, 42]); // brown
            vertexColors[7] = vec3.clone([128, 0, 0]);// maroon
            var indices = [a, b, c, a, c, d];
            for (var i = 0; i < indices.length; ++i) {
                points.push(...vertices[indices[i]]);
                // different color for all faces
                colors.push(...vertexColors[a]);
            }

            //adding normals for 6 vertices
            let aVector = vec3.create();
            let bVector = vec3.create();
            let normalVector = vec3.create();
            let normalVector4 = vec4.create();

            vec3.subtract(aVector, vertices[b], vertices[a]);
            vec3.subtract(bVector, vertices[c], vertices[b]);
            vec3.cross(normalVector, aVector, bVector);
            vec3.normalize(normalVector, normalVector);
            vec4.set(normalVector4, normalVector[0], normalVector[1], normalVector[2], 0.0);

            normalsArray.push(...normalVector4);
            normalsArray.push(...normalVector4);
            normalsArray.push(...normalVector4);
            normalsArray.push(...normalVector4);
            normalsArray.push(...normalVector4);
            normalsArray.push(...normalVector4);

        }
        function setupBuffers() {
            gl.useProgram(shaderProg);
            vertexArray = gl.createVertexArray();
            gl.bindVertexArray(vertexArray);
            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            setupVertices();
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            vertexBuffer.itemSize = 3;
            vertexBuffer.numberOfItems = points.length / 3;
            gl.enableVertexAttribArray(shaderProg.aPositionLoc);
            gl.vertexAttribPointer(shaderProg.aPositionLoc, 3, gl.FLOAT, false, 0, 0);

            colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(colors), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(shaderProg.vColor);
            gl.vertexAttribPointer(shaderProg.vColor, 3, gl.UNSIGNED_BYTE, true, 0, 0);

            normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalsArray), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(shaderProg.vNormal);
            gl.vertexAttribPointer(shaderProg.vNormal, 4, gl.FLOAT, false, 0, 0);


            gl.bindVertexArray(null);
            gl.useProgram(null);
            gl.useProgram(shaderProg2);
            vertexArray2 = gl.createVertexArray();
            gl.bindVertexArray(vertexArray2);
            vertexBuffer2 = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer2);
            var vertices = setupCoordinates();
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            vertexBuffer.itemSize = 3;
            vertexBuffer.numberOfItems = vertices.length / 3;
            gl.enableVertexAttribArray(shaderProg.aPositionLoc);
            gl.vertexAttribPointer(shaderProg.aPositionLoc, 3, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
            gl.useProgram(null);

        }

        function setupLights() {
            gl.useProgram(shaderProg);
            gl.uniform4fv(shaderProg.lightDiffuse, lightDiffuse);
            gl.uniform4fv(shaderProg.materialDiffuse, materialDiffuse);
            gl.uniform4fv(shaderProg.lightAmbient, lightAmbient);
            gl.uniform4fv(shaderProg.materialAmbient, materialAmbient);
            gl.uniform4fv(shaderProg.lightSpecular, lightSpecular);
            gl.uniform4fv(shaderProg.materialSpecular, materialSpecular);
            gl.uniform4fv(shaderProg.lightPosition, lightPosition);
            gl.uniform1f(shaderProg.shininess, materialShininess);
        }

        function draw() {
            gl.fClear();
            gl.useProgram(shaderProg);
            gl.bindVertexArray(vertexArray);
            if (flag) rtheta[axis] += 0.05;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            modelViewMatrix = mat4.create();
            normalMatrix = mat4.create();

            let eye = vec3.clone([radius * Math.sin(theta) * Math.cos(phi),
            radius * Math.sin(theta) * Math.sin(phi), radius * Math.cos(theta)]);
            mat4.lookAt(modelViewMatrix, eye, at, up);
            mat4.rotate(modelViewMatrix, modelViewMatrix, rtheta[xAxis], [1, 0, 0]);
            mat4.rotate(modelViewMatrix, modelViewMatrix, rtheta[yAxis], [0, 1, 0]);
            mat4.rotate(modelViewMatrix, modelViewMatrix, rtheta[zAxis], [0, 0, 1]);
            mat4.perspective(projectionMatrix, fovy, aspect, near, far);
            gl.uniformMatrix4fv(shaderProg.modelViewMatrixLoc, false, modelViewMatrix);

            mat4.invert(normalMatrix, modelViewMatrix);

            gl.uniformMatrix4fv(shaderProg.projectionMatrixLoc, false, projectionMatrix);
            gl.uniformMatrix4fv(shaderProg.normalMatrixLoc, true, normalMatrix);

            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 1.1, 0.0]);
            mat4.invert(normalMatrix, modelViewMatrix);
            gl.uniformMatrix4fv(shaderProg.modelViewMatrixLoc, false, modelViewMatrix);
            gl.uniformMatrix4fv(shaderProg.normalMatrixLoc, true, normalMatrix);
            drawTable();
            popModelViewMatrix();


            //creating shadow
            let shadowMatrix = mat4.create();
            shadowMatrix[15] = 0.0;
            shadowMatrix[7] = -1 / light[1];

            //pushModelViewMatrix();
            //mat4.translate(modelViewMatrix, modelViewMatrix, [light[0], light[1], light[2]]);
            //mat4.multiply(modelViewMatrix, modelViewMatrix, shadowMatrix);
            //mat4.translate(modelViewMatrix, modelViewMatrix, [-light[0], -light[1], -light[2]]);
            //mat4.invert(normalMatrix, modelViewMatrix);
            //gl.uniformMatrix4fv(shaderProg.modelViewMatrixLoc, false, modelViewMatrix);
            //gl.uniformMatrix4fv(shaderProg.normalMatrixLoc, true, normalMatrix);
            //gl.disableVertexAttribArray(shaderProg.vColor);
            //gl.vertexAttrib3f(shaderProg.vColor, 0.3, 0.3, 0.3);
            //drawTable();
            //gl.enableVertexAttribArray(shaderProg.vColor);
            //popModelViewMatrix();

            gl.bindVertexArray(null);
            gl.useProgram(null);
            //draw x-y axes
            gl.useProgram(shaderProg2);
            gl.bindVertexArray(vertexArray2);
            modelViewMatrix = mat4.create();
            mat4.lookAt(modelViewMatrix, eye, at, up);
            mat4.perspective(projectionMatrix, fovy, aspect, near, far);
            gl.uniformMatrix4fv(shaderProg2.modelViewMatrixLoc, false, modelViewMatrix);
            gl.uniformMatrix4fv(shaderProg2.projectionMatrixLoc, false, projectionMatrix);
            gl.disableVertexAttribArray(shaderProg2.vColor);
            gl.vertexAttrib3f(shaderProg2.vColor, 1.0, 0.0, 0.0);
            gl.drawArrays(gl.LINES, 0, 2);
            gl.vertexAttrib3f(shaderProg2.vColor, 0, 255, 0);
            gl.drawArrays(gl.LINES, 2, 2);
            gl.vertexAttrib3f(shaderProg2.vColor, 0, 0, 255);
            gl.drawArrays(gl.LINES, 4, 2);
            gl.bindVertexArray(null);
            gl.useProgram(null);
        }
        function pushModelViewMatrix() {
            var copyToPush = mat4.clone(modelViewMatrix);
            modelViewMatrixStack.push(copyToPush);
        }
        function popModelViewMatrix() {
            if (modelViewMatrixStack.length == 0) {
                throw "Error popModelViewMatrix() - Stack was empty ";
            }
            modelViewMatrix = modelViewMatrixStack.pop();
        }
        function drawTable() {
            // Draw table top
            pushModelViewMatrix();
            mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 1.0, 0.0]);
            mat4.scale(modelViewMatrix, modelViewMatrix, [2.0, 0.1, 2.0]);
            gl.uniformMatrix4fv(shaderProg.modelViewMatrixLoc, false, modelViewMatrix);
            gl.drawArrays(gl.TRIANGLES, 0, 36);
            popModelViewMatrix();
            // Draw table legs
            for (var i = -1; i <= 1; i += 2) {
                for (var j = -1; j <= 1; j += 2) {
                    pushModelViewMatrix();
                    mat4.translate(modelViewMatrix, modelViewMatrix, [i * 1.9, -0.1, j * 1.9]);
                    mat4.scale(modelViewMatrix, modelViewMatrix, [0.1, 1.0, 0.1]);
                    gl.uniformMatrix4fv(shaderProg.modelViewMatrixLoc, false, modelViewMatrix);
                    mat4.invert(normalMatrix, modelViewMatrix);
                    gl.uniformMatrix4fv(shaderProg.normalMatrixLoc, true, normalMatrix);
                    gl.drawArrays(gl.TRIANGLES, 0, 36);
                    popModelViewMatrix();
                }
            }
        }
    </script>

    <script>
        $(function () {
            $('#rotatex-btn').button();
            $('#rotatex-btn').click(
                function () {
                    if ($('#rotatex-btn:checked').val() == null) {
                    }
                    else {
                        axis = xAxis;
                    }
                });
            $('#rotatey-btn').button();
            $('#rotatey-btn').click(
                function () {
                    if ($('#rotatey-btn:checked').val() == null) {
                    }
                    else {
                        axis = yAxis;
                    }
                });
            $('#rotatez-btn').button();
            $('#rotatez-btn').click(
                function () {
                    if ($('#rotatez-btn:checked').val() == null) {
                    }
                    else {
                        axis = zAxis;
                    }
                });
            $('#rotatet-btn').button();
            $('#rotatet-btn').click(
                function () {
                    if ($('#rotatet-btn:checked').val() == null) {
                    }
                    else {
                        flag = !flag;
                    }
                });
            $("#increaseZ-btn").button();
            $("#increaseZ-btn").click(function () { near *= 1.1; far *= 1.1; });
            $("#decreaseZ-btn").button();
            $("#decreaseZ-btn").click(function () { near *= 0.9; far *= 0.9; });
            $("#increaseRadius-btn").button();
            $("#increaseRadius-btn").click(function () { radius *= 1.1; });
            $("#decreaseRadius-btn").button();
            $("#decreaseRadius-btn").click(function () { radius *= 0.9; });
            $("#increaseTheta-btn").button();
            $("#increaseTheta-btn").click(function () { theta += dr; });
            $("#decreaseTheta-btn").button();
            $("#decreaseTheta-btn").click(function () { theta -= dr; });
            $("#increasePhi-btn").button();
            $("#increasePhi-btn").click(function () { phi += dr; });
            $("#decreasePhi-btn").button();
            $("#decreasePhi-btn").click(function () { phi -= dr; });
            $('#colorSelectorSphere').ColorPicker({
                onSubmit: function (hsb, hex, rgb, el) {
                    $(el).val(hex);
                    $(el).ColorPickerHide();

                },
                color: '#00ff00',
                onShow: function (colpkr) {
                    $(colpkr).fadeIn(500);
                    return false;
                },
                onHide: function (colpkr) {
                    $(colpkr).fadeOut(500);
                    return false;
                },
                onChange: function (hsb, hex, rgb) {
                    $('#colorSelectorSphere div').css('backgroundColor', '#' + hex);
                    updateObjectColor(rgb.r / 256, rgb.g / 256, rgb.b / 256);
                },

                onBeforeShow: function (colpkr) {
                    $(colpkr).ColorPickerSetColor('rgb(0.5,0.8,0.1)');
                }
            })

            $('#slider-x').slider({ value: 0.0, min: -1.01, max: 1.01, step: 0.01, slide: updateLightDirection });
            $('#slider-y').slider({ value: -1.0, min: -1.01, max: 1.01, step: 0.01, slide: updateLightDirection });
            $('#slider-z').slider({ value: -1.0, min: -1.01, max: 1.01, step: 0.01, slide: updateLightDirection });
            $('#slider-ld').slider({ value: 1.0, min: -0.01, max: 1.01, step: 0.01, slide: updateLightDiffuseTerm });



            function updateProjection() {
                fovy = $('#slider-fovy').slider("value");
                $('#slider-fovy-value').html(fovy);
                aspect = $('#slider-aspect').slider("value");
                $('#slider-aspect-value').html(aspect);
            }
            $('#slider-fovy').slider({ value: 45, min: 10, max: 120, step: 5, slide: updateProjection });
            $('#slider-aspect').slider({ value: 1, min: 0.5, max: 2, step: 0.1, slide: updateProjection });
            function updateX() {
                light[0] = $('#slider-x').slider("value");
                $('#slider-x-value').html(light[0]);
            }
            function updateY() {
                light[1] = $('#slider-y').slider("value");
                $('#slider-y-value').html(light[1]);
            }
            function updateZ() {
                light[2] = $('#slider-z').slider("value");
                $('#slider-z-value').html(light[2]);
            }
            $('#slider-x').slider({ value: 0, min: -5, max: 5, step: 1, slide: updateX });
            $('#slider-y').slider({ value: 2, min: -5, max: 5, step: 1, slide: updateY });
            $('#slider-z').slider({ value: 0, min: -5, max: 5, step: 1, slide: updateZ });


            function updateObjectColor(r, g, b) {
                gl.uniform4fv(shaderProg.materialDiffuse, [r, g, b, 1.0]);
            }

            function updateLightDirection() {
                var x = $('#slider-x').slider("value");
                var y = $('#slider-y').slider("value");
                var z = $('#slider-z').slider("value");
                gl.uniform4fv(shaderProg.lightPosition, [x, y, z, 0.0]);

                $('#slider-x-value').html(x);
                $('#slider-y-value').html(y);
                $('#slider-z-value').html(z);
            }

            function updateLightDiffuseTerm() {
                var ld = $('#slider-ld').slider("value");
                gl.uniform4fv(shaderProg.lightDiffuse, [ld, ld, ld, 1.0]);
                $('#slider-ld-value').html(ld);
            }

        });
    </script>

</head>
<body>
    <div id="overlay">
        Interactive Shading of a table. X-axis: Red, Y-axis: Green, Z-axis: Blue
        <p />


        <div>
            <table>
                <tr>
                    <td align='left'>light(x)</td>
                    <td id='slider-x-value' width='30px' align='center'>0</td>
                    <td width='150px'><div id='slider-x' /></td>
                    <td align='left'>light(y)</td>
                    <td id='slider-y-value' width='30px' align='center'>0</td>
                    <td width='150px'><div id='slider-y' /></td>
                    <td align='left'>light(z)</td>
                    <td id='slider-z-value' width='30px' align='center'>0</td>
                    <td width='150px'><div id='slider-z' /></td>
                </tr>
            </table>
        </div>
        <div>
            <table>
                <tr>
                    <td><label id='lblrotatex' for='rotatex-btn'>Rotate X</label><input id='rotatex-btn' type='checkbox' /></td>
                    <td><label id='lblrotatey' for='rotatey-btn'>Rotate Y</label><input id='rotatey-btn' type='checkbox' /></td>
                    <td><label id='lblrotatez' for='rotatez-btn'>Rotate Z</label><input id='rotatez-btn' type='checkbox' /></td>
                    <td><label id='lblrotatet' for='rotatet-btn'>Toggle Rotation</label><input id='rotatet-btn' type='checkbox' /></td>
                    <td align='left'>fovy</td>
                    <td id='slider-fovy-value' width='30px' align='center'>120</td>
                    <td width='150px'><div id='slider-fovy' /></td>
                    <td align='left'>aspect</td>
                    <td id='slider-aspect-value' width='30px' align='center'>2</td>
                    <td width='150px'><div id='slider-aspect' /></td>

                </tr>
            </table>

            <p />
            <button id="increaseZ-btn">Increase Z</button>
            <button id="decreaseZ-btn">Decrease Z</button>
            <button id="increaseRadius-btn">Increase R</button>
            <button id="decreaseRadius-btn">Decrease R</button>
            <p> </p>
            <button id="increaseTheta-btn">Increase theta</button>
            <button id="decreaseTheta-btn">Decrease theta</button>
            <button id="increasePhi-btn">Increase phi</button>
            <button id="decreasePhi-btn">Decrease phi</button>

        </div>
        <p></p>
        <table>
            <tr>
                Light Direction:
                <td>X:</td>
                <td id='slider-x-value' width='30px' align='center'>0.0</td>
                <td width='150px'><div id='slider-x' /></td>
            </tr>
            <tr>
                <td>Y:</td>
                <td id='slider-y-value' width='30px' align='center'>-1.0</td>
                <td width='150px'><div id='slider-y' /></td>
            </tr>
            <tr>
                <td>Z:</td>
                <td id='slider-z-value' width='30px' align='center'>-1.0</td>
                <td width='150px'><div id='slider-z' /></td>
            </tr>
            <tr>
                <td colspan="2"> Sphere Color (Material Diffuse Term:</td>
                <td>
                    <div id='colorSelectorSphere' class='colorSelector'><div style='background-color:rgb(128,204,26)'></div></div>
                </td>
                <td align='right'>Light Diffuse Term:</td>
                <td id='slider-ld-value' width='30px'>1.0</td>
                <td width='150px' colspan='3'><div id='slider-ld' /></td>
            </tr>
            <tr>
        </table>
    </div>
    </div>

    <div>
        <canvas id="myGLCanvas"></canvas>
    </div>

    <script id="vertex_shader" type="x-shader/x-vertex">#version 300 es
        in vec3 a_position;
        in vec3 vColorAttr;
        out vec4 vColor;
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;

        in vec4 vNormalAttr;
        uniform vec4 lightPosition;
        uniform mat4 normalMatrix;

        out vec3 L;
        out vec3 N;
        out vec3 E;

        void main(void){

        // pos is vertex position in eye coordinates
        vec3 pos = (modelViewMatrix * vec4(a_position, 1.0)).xyz;

        //Transformed normal position
        N = vec3(normalMatrix * vNormalAttr);

        vec3 eyeVec = -vec3(pos);
        E = eyeVec;

        // check for directional light

        if(lightPosition.w == 0.0) L = lightPosition.xyz;
        else L =  lightPosition.xyz - pos ;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(a_position, 1.0);
        vColor = vec4(vColorAttr, 1.0);
        }
    </script>
    <script id="fragment_shader" type="x-shader/x-fragment">#version 300 es
        precision mediump float;
        in vec4 vColor;
        out vec4 finalColor;

        uniform vec4 lightDiffuse;
        uniform vec4 materialDiffuse;
        uniform vec4 lightAmbient;
        uniform vec4 materialAmbient;
        uniform vec4 lightSpecular;
        uniform vec4 materialSpecular;
        uniform float shininess;

        in vec3 L;
        in vec3 N;
        in vec3 E;
        vec3 nL, nN, nE;

        void main(void) {

        nE = normalize(E);
        nN = normalize(N);
        nL = normalize(L);

        //Lambert's cosine law
        float lambertTerm = dot(nN,-nL);

        float Kd = max (dot (nN, -nL) , 0.0);
        //Ambient Term
        vec4 Ia = lightAmbient * materialAmbient;

        //Diffuse Term
        vec4 Id = vec4(0.0,0.0,0.0,1.0);

        //Specular Term
        vec4 Is = vec4(0.0,0.0,0.0,1.0);

        if(lambertTerm > 0.0) //only if lambertTerm is positive
        {
        Id = lightDiffuse* materialDiffuse * lambertTerm; //add diffuse term

        vec3 R = reflect(nL, nN);
        float specular = pow(max(dot(R, nE), 0.0), shininess );

        Is = lightSpecular * materialSpecular * specular; //add specular term
        }

        finalColor = Ia + Id + Is;
        finalColor.a = 1.0;
        finalColor = finalColor * vColor;
        }
    </script>
    <script id="vertex_shader2" type="x-shader/x-vertex">#version 300 es
        in vec3 a_position;
        in vec3 vColorAttr;
        out vec4 vColor;
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        void main(void){
        gl_Position = projectionMatrix * modelViewMatrix * vec4(a_position, 1.0);
        vColor = vec4(vColorAttr, 1.0);
        }
    </script>
    <script id="fragment_shader2" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        in vec4 vColor;
        out vec4 finalColor;
        void main(void) {
        finalColor = vColor;
        }
    </script>

</body>
</html>